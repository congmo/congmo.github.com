
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>REST isn't what you think it is (and that's OK) - 葱末COngMo</title>
  <meta name="author" content="xiaori.liu">

  
  <meta name="description" content="Everyone says they have a REST (or RESTful or REST-like) API. Twitter does, Facebook does, as does Twilio and Gowalla and even Google. However, by &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://congmo.github.com/blog/2010/04/29/rest-isnt-what-you-think-it-is">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="葱末COngMo" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href='http://fonts.googleapis.com/css?family=Rock+Salt' rel='stylesheet' type='text/css'>
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">葱末COngMo</a></h1>
  
    <h2>与人玫瑰，手有余香.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:congmo.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">REST Isn't What You Think It Is (and That's OK)</h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-04-29T00:00:00+08:00" pubdate data-updated="true">Apr 29<span>th</span>, 2010</time>
        
      </p>
    
  </header>


<div class="entry-content"><p>Everyone says they have a <span class="caps">REST</span> (or RESTful or <span class="caps">REST</span>-like) <span class="caps">API</span>. <a href="http://apiwiki.twitter.com/REST-API-Documentation">Twitter does</a>, <a href="http://wiki.developers.facebook.com/index.php/API">Facebook does</a>, as does <a href="http://www.twilio.com/docs/api/2008-08-01/rest/">Twilio</a> and <a href="http://gowalla.com/api/docs">Gowalla</a> and even <a href="http://code.google.com/apis/ajaxsearch/documentation/#fonje">Google</a>. However, by the actual, original definition, none of them are truly RESTful. But that&#8217;s OK, because your <span class="caps">API</span> shouldn&#8217;t be either.</p>
<h3>The Common Definition</h3>
<p>The misconception lies in the fact that, as tends to happen, the popular definition of a technical term has come to mean something entirely different from its original meaning. To most people, being RESTful means a few things:</p>
<ol>
	<li>Well-defined URIs that &#8220;represent&#8221; some kind of resource, such as &#8220;/posts&#8221; on a blog representing the blog posts.</li>
	<li><span class="caps">HTTP</span> methods being used as verbs to perform actions on that resource (i.e. <code>GET</code> for read operations and <code>POST</code> for write operations).</li>
	<li>The ability to access multiple format representations of the same data (i.e. both a <span class="caps">JSON</span> and an <span class="caps">XML</span> representation of a blog post).</li>
</ol>
<p>There are some other parts of the common vocabulary of <span class="caps">REST</span> (for example, for some developers being RESTful would also imply a <span class="caps">URI</span> hierarchy such that <code>/posts/{uniqueid}</code> would be seen to be a member of the <code>/posts</code> collection), but these are what most people think of when they hear &#8220;RESTful web service.&#8221; So how is this different from the &#8220;actual&#8221; definition of <span class="caps">REST</span>?</p>
<h3>Diverging From Canon</h3>
<p>By the common definition of <span class="caps">REST</span>, a service defines a set of resources and actions that can be accessed via <span class="caps">URI</span> endpoints. However, the &#8220;true&#8221; definition of <span class="caps">REST</span> demands that resources be self-describing, providing all of the control context in-band of the provided representation. No out-of-band knowledge should, therefore, be required beyond understanding a media type that the resource can provide. From there, it should be possible to follow relations provided in &#8220;hypertext&#8221; context of the representation to &#8220;transfer state&#8221;, follow relations, or perform any necessary actions.</p>
<p>Another common divergence comes through the practice of using <span class="caps">HTTP</span> <code>POST</code> (or <code>PUT</code>) bodies with key-value pairs to create and update documents. In a canonically RESTful service clients should be posting an actual representation of the document in an accepted media type that is then parsed and translated by the service provider to create or update the resource.</p>
<p>Still more divergence comes in the common practice of denoting collections and elements. A truly RESTful web service has no concept of a &#8220;collection&#8221; of resources. There are only resources. As such, the proper way to implement a collection would be to define a separate resource that represents a collection of other resources.</p>
<h3>Is anything truly RESTful?</h3>
<p>Pretty much everyone who claims to have a <span class="caps">REST</span> <span class="caps">API</span>, in fact, does not. The closest I&#8217;ve found is the <a href="http://kenai.com/projects/suncloudapis/pages/Home">Sun Cloud <span class="caps">API</span></a> which actually defines a number of custom media types for resources and is discoverable based on a single known end-point. Everyone else, thanks for playing.</p>
<p>There is, however, one public and <strong>extremely</strong> widely used system that is entirely RESTful. It&#8217;s called the world wide web. Yes, as you&#8217;re browsing the internet you&#8217;re engaging in a <span class="caps">REST</span> service by the true definition of the name. Does your browser (the client) know whether it&#8217;s displaying a banking website or a casual game? Nope, it just utilizes standard media types (<span class="caps">HTML</span>, <span class="caps">CSS</span>, Javascript) to compose and represent the data. You don&#8217;t have to know the specific <span class="caps">URL</span> you&#8217;re looking for on a website so long as you know the &#8220;starting place&#8221; (usually the domain name) and can navigate there.</p>
<p>So <span class="caps">REST</span> by its original definition is far from useless. In fact, it&#8217;s an ingenious and flexible way to allow for the consumption and traversal of network-available information. What it&#8217;s not, however, is a very good roadmap toward building APIs for web applications.</p>
<h3>Real <span class="caps">REST</span> is too hard.</h3>
<p>Truly RESTful services simply require too much work to be practical for most applications. Too much work from the provider in defining and supporting custom media types with complex modeled relationships transmitted in-band. Too much work for clients and library authors to perform complex aggregation and re-formulation of data to make it conform to the real <span class="caps">REST</span> style. Real <span class="caps">REST</span> is great for generic, broad-encompassing multi-provider architectures that need the flexibility and discoverability it provides. For most application developers it&#8217;s simply overkill and a real implementation headache.</p>
<p>There&#8217;s nothing wrong with the common definition of <span class="caps">REST</span>. It&#8217;s leaps and bounds better than some of the methods that came before it and pretty much everyone is already on board and familiar with how it works. It&#8217;s a pragmatic solution that really works pretty well for everyone. As they say, if it ain&#8217;t broke, don&#8217;t fix it.</p>
<h3>What&#8217;s in a name?</h3>
<p>The only problem is that now we have lots of things that we&#8217;re calling <span class="caps">REST</span> that aren&#8217;t. Roy T. Fielding, primary architect of <span class="caps">HTTP</span> 1.1 and the author of the dissertation that originally defines <span class="caps">REST</span>, <a href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven">hasn&#8217;t always been happy with people calling things <span class="caps">REST</span> that aren&#8217;t</a>. And maybe he has a point: these services certainly aren&#8217;t <span class="caps">REST</span> by his definition and because of the wide propagation of this incorrect definition of <span class="caps">REST</span> most people now don&#8217;t really understand the true definition. In fact, I don&#8217;t claim to have a great understanding of <span class="caps">REST</span> as Dr. Fielding defines it.</p>
<p>The problem is that the ship has sailed, and whether it&#8217;s true or not, <span class="caps">REST</span> now <strong>also</strong> means any simple, <span class="caps">URL</span>-accessible resource-based service. Perception is reality, and perception has changed about the definition of <span class="caps">REST</span> and RESTful. While the true definition is interesting for academic purposes and certainly lies behind the technologies upon which we build every day, it simply doesn&#8217;t have a whole lot of use to web application developers. The fact that (nearly) zero services exist that implement true <span class="caps">REST</span> for their <span class="caps">API</span> serves as testament to that.</p>
<h3>What can we learn from <span class="caps">REST</span>?</h3>
<p>Just because we don&#8217;t use true <span class="caps">REST</span> doesn&#8217;t mean there aren&#8217;t a few things we can learn from it. There are a few aspects that I&#8217;d love to see come into favor in the common definition. The idea of clients needing to know a few media types instead of specific protocols for each service is one that breaks down in practice for APIs due to the overwhelming number of web services with different needs in terms of domain-specific resource definition. However, wouldn&#8217;t it be great if there were an accepted  <code>application/x-person+json</code> format that provided a standardized batch of user information (such as name, e-mail address, location, profile image <span class="caps">URL</span>) that you could request from Facebook, Twitter, Google or any OpenID provider and expect conforming data? Just because there are lots of domain-specific resources doesn&#8217;t mean that it isn&#8217;t worthwhile to try to come up with some standards for common information.</p>
<p><span class="caps">REST</span>-like discoverability could also be a boon for some services. What if Twitter provided something like this along with a tweet&#8217;s <span class="caps">JSON</span>?</p>
<pre name='code' class='json'>{
  "actions": {
    "Retweet" : { "method":"POST", url:"/1/statuses/retweet/12345.json" },
    "Delete" : { "method":"DELETE", url:"/1/statuses/destroy/12345.json" },
    "Report Spam" : { "method":"POST", url:"/1/statuses/retweet/12345.json", params:{"id":12345} }
  }
}</pre>
<p>So while <span class="caps">REST</span> as originally intended may not be a great fit for web applications, there are still patterns and practices to be gleaned from a better understanding of how such a service could work. For web applications, the case may be that <span class="caps">REST</span> is dead, long live <span class="caps">REST</span>!</p></div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">xiaori.liu</span></span>

      








  


<time datetime="2010-04-29T00:00:00+08:00" pubdate data-updated="true">Apr 29<span>th</span>, 2010</time>
      


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://congmo.github.com/blog/2010/04/29/rest-isnt-what-you-think-it-is/" data-via="" data-counturl="http://congmo.github.com/blog/2010/04/29/rest-isnt-what-you-think-it-is/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2010/04/28/the-futures-pretty-cool/" title="Previous Post: The Future's Pretty Cool (or Why I Love Ruby)">&laquo; The Future's Pretty Cool (or Why I Love Ruby)</a>
      
      
        <a class="basic-alignment right" href="/blog/2010/06/01/authbuttons-free-open-source-web-app-icons/" title="next Post: AuthButtons: Free and Open Source Web App Icons">AuthButtons: Free and Open Source Web App Icons &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2012/02/01/test-chinese/">Guest Post on RubyLearning: 中文Building DSLs with yield and instance_eval</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/01/17/2/">MultiJSON: The Swappable JSON Handler</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/01/16/testtesttest/">teesesest</a>
      </li>
    
      <li class="post">
        <a href="/blog/2010/11/30/rubylearning-guest-post/">Guest Post on RubyLearning: Building DSLs with yield and instance_eval</a>
      </li>
    
      <li class="post">
        <a href="/blog/2010/10/03/omniauth-flexible-authentication-for-rack/">OmniAuth: Flexible, Unassuming Multi-Provider Authentication for Rack</a>
      </li>
    
  </ul>
</section>






  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2012 - xiaori.liu -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
